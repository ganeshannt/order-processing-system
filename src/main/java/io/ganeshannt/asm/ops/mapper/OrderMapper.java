package io.ganeshannt.asm.ops.mapper;

import io.ganeshannt.asm.ops.dto.OrderItemDTO;
import io.ganeshannt.asm.ops.dto.OrderRequestDTO;
import io.ganeshannt.asm.ops.dto.OrderResponseDTO;
import io.ganeshannt.asm.ops.entity.Order;
import io.ganeshannt.asm.ops.entity.OrderItem;
import org.mapstruct.*;

import java.math.BigDecimal;
import java.util.List;

/**
 * Order Mapper using MapStruct
 *
 * Why MapStruct instead of manual mapping?
 * 1. Performance: Generates bytecode at compile-time (no reflection)
 * 2. Type Safety: Compile-time errors if mapping is wrong
 * 3. Maintainability: Less boilerplate code
 * 4. Clarity: Explicit mapping configuration
 *
 * MapStruct vs ModelMapper vs Manual:
 * - MapStruct: Fastest, compile-time generation
 * - ModelMapper: Slower, runtime reflection
 * - Manual: Most control, most code, error-prone
 *
 * Configuration:
 * - componentModel = "spring": Creates Spring Bean
 * - unmappedTargetPolicy = IGNORE: Don't warn for unmapped fields
 * - injectionStrategy = CONSTRUCTOR: Use constructor injection (immutable)
 */
@Mapper(
        componentModel = "spring",
        unmappedTargetPolicy = ReportingPolicy.IGNORE,
        injectionStrategy = InjectionStrategy.CONSTRUCTOR
)
public interface OrderMapper {

    /**
     * Convert Order entity to OrderResponseDTO
     *
     * Mappings:
     * - Most fields auto-mapped by name
     * - items: List<OrderItem> → List<OrderItemDTO>
     *
     * MapStruct will:
     * 1. Create new OrderResponseDTO
     * 2. Copy all matching field names
     * 3. Recursively map nested objects (items)
     */
    @Mapping(target = "items", source = "items")
    OrderResponseDTO toResponseDTO(Order order);

    /**
     * Convert list of Orders to list of OrderResponseDTOs
     *
     * Why this method?
     * - MapStruct auto-generates it from single object mapping
     * - Convenient for returning multiple orders
     */
    List<OrderResponseDTO> toResponseDTOList(List<Order> orders);

    /**
     * Convert OrderRequestDTO to Order entity
     *
     * Complex Mapping Notes:
     * - id: Ignored (generated by database)
     * - status: Ignored (set by business logic)
     * - createdAt/updatedAt: Ignored (set by JPA)
     * - totalAmount: Calculated after mapping
     * - items: Mapped with custom logic
     *
     * @AfterMapping: Post-processing after MapStruct finishes
     * - Calculate total amount
     * - Set bidirectional relationships
     */
    @Mapping(target = "id", ignore = true)
    @Mapping(target = "status", ignore = true)
    @Mapping(target = "createdAt", ignore = true)
    @Mapping(target = "updatedAt", ignore = true)
    @Mapping(target = "totalAmount", ignore = true)
    Order toEntity(OrderRequestDTO dto);

    /**
     * Post-mapping processing
     *
     * Why @AfterMapping?
     * - Handle logic that can't be expressed in @Mapping
     * - Calculate derived values
     * - Set relationships
     *
     * This method:
     * 1. Sets bidirectional relationship (order ↔ items)
     * 2. Calculates total amount from items
     */
    @AfterMapping
    default void linkItemsAndCalculateTotal(@MappingTarget Order order) {
        if (order.getItems() != null) {
            // Set bidirectional relationship
            order.getItems().forEach(item -> item.setOrder(order));

            // Calculate total amount
            BigDecimal total = order.getItems().stream()
                    .map(OrderItem::getLineTotal)
                    .reduce(BigDecimal.ZERO, BigDecimal::add);
            order.setTotalAmount(total);
        }
    }

    /**
     * Convert OrderItem entity to OrderItemDTO
     */
    @Mapping(target = "lineTotal", expression = "java(item.getLineTotal())")
    OrderItemDTO toItemDTO(OrderItem item);

    /**
     * Convert OrderItemDTO to OrderItem entity
     */
    @Mapping(target = "id", ignore = true)
    @Mapping(target = "order", ignore = true)
    OrderItem toItemEntity(OrderItemDTO dto);

    /**
     * Convert list of OrderItemDTOs to list of OrderItem entities
     */
    List<OrderItem> toItemEntityList(List<OrderItemDTO> dtos);
}
